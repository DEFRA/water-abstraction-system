'use strict'

// Test framework dependencies
const Lab = require('@hapi/lab')
const Code = require('@hapi/code')

const { describe, it } = exports.lab = Lab.script()
const { expect } = Code

// Test helpers
const { DBError } = require('objection')
const EventModel = require('../../app/models/water/event.model.js')

// Thing under test
const LegacyBaseModel = require('../../app/models/legacy-base.model.js')

describe('Legacy Base model', () => {
  describe('.schema', () => {
    describe('when the getter is not overridden', () => {
      class BadModel extends LegacyBaseModel {
        static get translations () {
          return []
        }
      }

      it('throws an error when called', () => {
        expect(() => BadModel.query()).to.throw()
      })
    })

    describe('when the getter is overridden', () => {
      class GoodModel extends LegacyBaseModel {
        static get schema () {
          return 'water'
        }

        static get translations () {
          return []
        }
      }

      it('does not throw an error when called', () => {
        expect(() => GoodModel.query()).not.to.throw()
      })
    })
  })

  describe('.translations', () => {
    describe('when the getter is not overridden', () => {
      class BadModel extends LegacyBaseModel {
        static get schema () {
          return 'water'
        }
      }

      it('throws an error when called', () => {
        const instance = new BadModel()
        expect(() => instance.$toJson()).not.to.throw()
      })
    })

    describe('when the getter is overridden', () => {
      class GoodModel extends LegacyBaseModel {
        static get schema () {
          return 'water'
        }

        static get translations () {
          return []
        }
      }

      it('does not throw an error when called', () => {
        const instance = new GoodModel()
        expect(() => instance.$toJson()).not.to.throw()
      })
    })
  })

  describe('when working with Legacy model instances', () => {
    describe('and the legacy table a model is based on has non-standard columns', () => {
      class YeOldeBillingModel extends LegacyBaseModel {
        static get translations () {
          return [
            { database: 'yehAlrightLove', model: 'greeting' },
            { database: 'doesNotExist', model: 'notHere' }
          ]
        }
      }

      const dummyDatabaseJson = {
        billingId: '76353750-5ace-411a-b00c-4e4a9ac934fb',
        yehAlrightLove: 'Hello'
      }

      const dummyModelJson = {
        billingId: '76353750-5ace-411a-b00c-4e4a9ac934fb',
        greeting: 'Hello'
      }

      describe('when translating from the database table', () => {
        it('translates them to standard model properties', () => {
          const yeOldeBilling = new YeOldeBillingModel()

          // You would never call this directly. $parseDatabaseJson() is an objection method we're overloading in
          // LegacyBaseModel. But it gives us the JSON Objection.js will then use to build the model so it works for this
          // test. The JSON it expects as a param is generated by Objection based on the table in the DB.
          // Note: The spread operator is used to create a shallow clone as $parseDatabaseJson() amends the value passed
          // in. That would break subsequent tests
          const result = yeOldeBilling.$parseDatabaseJson({ ...dummyDatabaseJson })

          expect(result).to.equal(dummyModelJson)
        })

        it('ignores any translations that do not exist', () => {
          const yeOldeBilling = new YeOldeBillingModel()

          const result = yeOldeBilling.$parseDatabaseJson({ ...dummyDatabaseJson })

          expect(result.notHere).not.to.exist()
        })
      })

      describe('when translating back from the model instance', () => {
        it('translates the model properties back to non-standard columns', () => {
          const yeOldeBilling = new YeOldeBillingModel()

          // You would never call this directly. $formatDatabaseJson() is an objection method we're overloading in
          // LegacyBaseModel. But it gives us the JSON Objection.js will then use to build to build the query so it works
          // for this test. The JSON it expects as a param is generated by Objection based on the model instance.
          // Note: The spread operator is used to create a shallow clone as $formatDatabaseJson() amends the value passed
          // in. That would break subsequent tests
          const result = yeOldeBilling.$formatDatabaseJson({ ...dummyModelJson })

          expect(result).to.equal(dummyDatabaseJson)
        })

        it('ignores any translations that do not exist', () => {
          const yeOldeBilling = new YeOldeBillingModel()

          const result = yeOldeBilling.$formatDatabaseJson({ ...dummyModelJson })

          expect(result.doesNotExist).not.to.exist()
        })
      })
    })
  })

  describe('when working with Legacy model classes', () => {
    describe('and the legacy table a model is based on has non-standard columns', () => {
      it('throws an error when a query uses the standard model property name', async () => {
        const timeNow = new Date().toISOString()

        const error = await expect(EventModel.query().where('createdAt', '<', timeNow)).to.reject()
        expect(error).to.be.an.instanceOf(DBError)
      })
    })
  })
})
