'use strict'

// Test framework dependencies
const Lab = require('@hapi/lab')
const Code = require('@hapi/code')
const Sinon = require('sinon')

const { describe, it, beforeEach, afterEach } = (exports.lab = Lab.script())
const { expect } = Code

// Things we need to stub
const jwt = require('jsonwebtoken')
const notifyConfig = require('../../config/notify.config.js')

// For running our service
const { init } = require('../../app/server.js')

const TWENTY_SECONDS_IN_MILLISECONDS = 20000
const THIRTY_SECONDS_IN_MILLISECONDS = 30000

describe('Notify Token Cache plugin', () => {
  let clock
  let jwtSignSpy
  let server
  let testDate

  beforeEach(async () => {
    // NOTE: We stub the UserModel `findById().select()` query to avoid hitting the DB as part of the test. It is
    // sufficiently simple running it would just be testing Objection.js and not our logic.
    // Sinon.stub(NotifyConfig, 'apiKey').value(
    //   'my_test_key-26785a09-ab16-4eb0-8407-a37497a57506-3d844edf-8d35-48ac-975b-e847b4f122b0'
    // )
    jwtSignSpy = Sinon.spy(jwt, 'sign')

    testDate = new Date('2025-08-19T11:03:00.000Z')
    clock = Sinon.useFakeTimers(testDate)

    // Create server before each test
    server = await init()

    // NOTE: We stub the UserModel `findById().select()` query to avoid hitting the DB as part of the test. It is
    // sufficiently simple running it would just be testing Objection.js and not our logic.
    Sinon.stub(notifyConfig, 'apiKey').value(
      'my_test_key-26785a09-ab16-4eb0-8407-a37497a57506-3d844edf-8d35-48ac-975b-e847b4f122b0'
    )
  })

  afterEach(() => {
    clock.restore()
    Sinon.restore()
  })

  describe('When called', () => {
    it('returns a signed JSON web token', async () => {
      const result = await server.methods.getNotifyToken()

      expect(result).not.to.be.null()

      const jwtSignFirstCall = jwtSignSpy.firstCall.args

      expect(jwtSignFirstCall).to.equal([
        {
          iss: '26785a09-ab16-4eb0-8407-a37497a57506',
          iat: 1755601380
        },
        '3d844edf-8d35-48ac-975b-e847b4f122b0',
        {
          header: { typ: 'JWT', alg: 'HS256' }
        }
      ])
    })
  })

  describe('When called a second time within 25 seconds of the first call', () => {
    it('returns the cached signed JSON web token generated by the first call', async () => {
      const firstCall = await server.methods.getNotifyToken()

      expect(firstCall).not.to.be.null()

      // Jump forwards in time 20 seconds
      clock.jump(TWENTY_SECONDS_IN_MILLISECONDS)

      const secondCall = await server.methods.getNotifyToken()

      expect(firstCall).to.equal(secondCall)

      expect(jwtSignSpy.calledOnce).to.be.true()
    })
  })

  describe('When called a second time more than 25 seconds after the first call', () => {
    it('returns a new JSON web token', async () => {
      const firstCall = await server.methods.getNotifyToken()

      expect(firstCall).not.to.be.null()

      // Jump forwards in time 30 seconds
      clock.jump(THIRTY_SECONDS_IN_MILLISECONDS)

      const secondCall = await server.methods.getNotifyToken()

      expect(firstCall).not.to.equal(secondCall)

      expect(jwtSignSpy.calledTwice).to.be.true()
    })
  })
})
